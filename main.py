import os
import asyncio
import re
import json
import nest_asyncio
nest_asyncio.apply()

# üöÄ Aiogram Imports
from aiogram import Bot, Dispatcher, Router, types
from aiogram.types import (
    Message,
    FSInputFile,
    ReplyKeyboardMarkup,
    KeyboardButton,
    InlineKeyboardMarkup,
    InlineKeyboardButton
)
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties
from aiogram.filters import CommandStart

# ü§ñ Telethon Imports
from telethon import TelegramClient, events
from telethon.sessions import StringSession
from telethon.tl.functions.account import GetAuthorizationsRequest, ResetAuthorizationRequest
from telethon.tl.functions.messages import DeleteHistoryRequest
from telethon.tl.functions.channels import LeaveChannelRequest
from telethon.tl.functions.contacts import (
    DeleteContactsRequest,
    ImportContactsRequest,
    GetContactsRequest
)
from telethon.tl.types import InputPhoneContact, InputUser

# ‚òÅÔ∏è Google Drive API Imports
from google.oauth2.credentials import Credentials
from google.auth.transport.requests import Request
from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload
from googleapiclient.errors import HttpError

# üîπ ‡¶§‡ßã‡¶Æ‡¶æ‡¶∞ Drive Folder ID
GOOGLE_FOLDER_ID = "10PhKlbF6TFz5CTaTQiKDFwmQxGu8gTMF"

# üîπ Token ‡¶´‡¶æ‡¶á‡¶≤‡ßá‡¶∞ ‡¶®‡¶æ‡¶Æ (auto refresh ‡¶π‡¶≤‡ßá ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶∏‡ßá‡¶≠ ‡¶π‡¶¨‡ßá)
TOKEN_FILE = "token.json"

# üîπ ‡¶ï‡ßç‡¶∞‡ßá‡¶°‡ßá‡¶®‡¶∂‡¶ø‡ßü‡¶æ‡¶≤ ‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ
def load_credentials():
    if os.path.exists(TOKEN_FILE):
        with open(TOKEN_FILE, "r") as f:
            data = json.load(f)
            return Credentials.from_authorized_user_info(data)
    else:
        # üëâ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡¶¨‡¶æ‡¶∞‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßÅ‡ßü‡¶æ‡¶≤‡¶ø ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶¨‡¶∏‡¶æ‡¶ì (‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶Ø‡ßá‡¶ü‡¶æ ‡¶¶‡¶ø‡ßü‡ßá‡¶õ‡ßã)
        creds = Credentials(
            token="ya29.a0ATi6K2tM5RICjBCL1D3lOW5Fm8xjEl3OMd9sIYL6VyMXBVNWbAQNxB-ThBv8tV14LbYIdnHN7ZQpqcz60b1Jy5mUypsExwDdbjHgs_-A6ZB6HWxSbpqh8G99Mjq-nny2wtWwWNA2l0ApjaCpsP-qiLI0PZIIqKWvUrElV9-SF4iz5PI5F1OtGwpVJ3ScUeRvGrGoRUUaCgYKAdUSARESFQHGX2MiiD8DQilhsZckD_4AyLy9aw0206",
            refresh_token="1//0ccJG0M2N5PDvCgYIARAAGAwSNwF-L9IrsGedoagIRQiVcw7nckAgMDg-KYvXOXjTeAKL22PmEb8ioca5sHmWhZ6J6VkI3tMfIRA",
            token_uri="https://oauth2.googleapis.com/token",
            client_id="29510678393-onbisk73ubkihqpbg0hacp9hmn2drtk6.apps.googleusercontent.com",
            client_secret="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",
            scopes=["https://www.googleapis.com/auth/drive"]
        )
        # üîπ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡¶¨‡¶æ‡¶∞ ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡ßá ‡¶∞‡¶æ‡¶ñ‡¶¨‡ßá
        save_credentials(creds)
        return creds

# üîπ ‡¶ï‡ßç‡¶∞‡ßá‡¶°‡ßá‡¶®‡¶∂‡¶ø‡ßü‡¶æ‡¶≤ ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡¶æ
def save_credentials(creds):
    with open(TOKEN_FILE, "w") as f:
        f.write(creds.to_json())

# üîπ ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶∞‡¶ø‡¶´‡ßç‡¶∞‡ßá‡¶∂ ‡¶Ö‡¶ü‡ßã ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ
def ensure_valid_token():
    global creds
    if creds.expired and creds.refresh_token:
        try:
            creds.refresh(Request())
            save_credentials(creds)
            print("üîÅ Token auto-refreshed successfully!")
        except Exception as e:
            print("‚ö†Ô∏è Token refresh failed:", e)

# üîπ ‡¶≤‡ßã‡¶° ‡¶ì ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶ø‡¶∏ ‡¶§‡ßà‡¶∞‡¶ø
creds = load_credentials()
drive_service = build("drive", "v3", credentials=creds)


# üîπ ‡¶Ü‡¶™‡¶≤‡ßã‡¶° ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®
def upload_to_drive(file_path, file_name):
    """Google Drive ‡¶è ‡¶´‡¶æ‡¶á‡¶≤ ‡¶Ü‡¶™‡¶≤‡ßã‡¶° (Auto Token Refresh ‡¶∏‡¶π)"""
    try:
        ensure_valid_token()  # ‚úÖ ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶ö‡ßá‡¶ï ‡¶ì ‡¶∞‡¶ø‡¶´‡ßç‡¶∞‡ßá‡¶∂

        file_metadata = {"name": file_name, "parents": [GOOGLE_FOLDER_ID]}
        media = MediaFileUpload(file_path, resumable=True)

        uploaded_file = drive_service.files().create(
            body=file_metadata,
            media_body=media,
            fields="id"
        ).execute()

        print(f"‚úÖ Uploaded successfully: {uploaded_file.get('id')}")
        return uploaded_file.get("id")

    except HttpError as e:
        err_msg = e.content.decode() if hasattr(e, "content") else str(e)
        print("‚ùå Google Drive error:", err_msg)
        raise Exception(f"Google Drive error: {err_msg}")
    except Exception as e:
        print("‚ö†Ô∏è Unexpected upload error:", e)
        raise

import io
from googleapiclient.http import MediaIoBaseDownload
import tempfile

def download_drive_file_to_tmp(file_id, filename=None):
    """Drive file download ‡¶ï‡¶∞‡ßá ‡¶≤‡ßã‡¶ï‡¶æ‡¶≤ ‡¶ü‡ßá‡¶Æ‡ßç‡¶™ ‡¶´‡¶æ‡¶á‡¶≤ ‡¶™‡¶• ‡¶∞‡¶ø‡¶ü‡¶æ‡¶∞‡ßç‡¶® ‡¶ï‡¶∞‡ßá"""
    if not filename:
        filename = file_id + ".session"
    tmp_dir = os.path.join("sessions", "tmp")
    os.makedirs(tmp_dir, exist_ok=True)
    local_path = os.path.join(tmp_dir, filename)
    request = drive_service.files().get_media(fileId=file_id)
    fh = io.FileIO(local_path, "wb")
    downloader = MediaIoBaseDownload(fh, request)
    done = False
    try:
        while not done:
            status, done = downloader.next_chunk()
    except Exception as e:
        fh.close()
        raise
    fh.close()
    return local_path

import phonenumbers
import pycountry

def get_country_flag(iso_code):
    """ISO country code ‡¶•‡ßá‡¶ï‡ßá ‡¶™‡¶§‡¶æ‡¶ï‡¶æ ‡¶á‡¶Æ‡ßã‡¶ú‡¶ø ‡¶§‡ßà‡¶∞‡¶ø"""
    try:
        return ''.join(chr(127397 + ord(c)) for c in iso_code.upper())
    except:
        return "üè≥Ô∏è"

def get_country_info(phone_number: str):
    """‡¶´‡ßã‡¶® ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶•‡ßá‡¶ï‡ßá ‡¶¶‡ßá‡¶∂‡ßá‡¶∞ ‡¶™‡¶§‡¶æ‡¶ï‡¶æ ‡¶ì ‡¶®‡¶æ‡¶Æ ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡ßá (‡¶∏‡ßç‡¶¨‡¶Ø‡¶º‡¶Ç‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º 195 ‡¶¶‡ßá‡¶∂‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø)"""
    try:
        parsed = phonenumbers.parse(phone_number, None)
        country_code = phonenumbers.region_code_for_number(parsed)
        if not country_code:
            return ("üåç", "Unknown")

        country = pycountry.countries.get(alpha_2=country_code)
        flag = get_country_flag(country_code)
        return (flag, country.name if country else "Unknown")
    except:
        return ("üåç", "Unknown")

# ‚úÖ ‡¶®‡¶§‡ßÅ‡¶® purge ‡¶Ö‡¶™‡¶∂‡¶® ‡¶ï‡ßÄ‡¶¨‡ßã‡¶∞‡ßç‡¶°
purge_option_keyboard = InlineKeyboardMarkup(inline_keyboard=[
    [InlineKeyboardButton(text="üßæ Delete Messages", callback_data="purge_messages")],
    [InlineKeyboardButton(text="üö™ Leave Groups", callback_data="purge_groups")],
    [InlineKeyboardButton(text="üìá Delete Contacts", callback_data="purge_contacts")]
])

API_ID = 29054703
API_HASH = "4306675966f08ae9f2d06cc59165db81"
BOT_TOKEN = "7972270179:AAFMVzaAl6qishsQ5-mr1MgIsIQSQ1MTVKY"

bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher()
router = Router()
dp.include_router(router)

SESSION_DIR = "sessions"
os.makedirs(SESSION_DIR, exist_ok=True)

user_state = {}

def get_user_session_dir(user_id):
    path = os.path.join("sessions", str(user_id))
    os.makedirs(path, exist_ok=True)
    return path

main_menu = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üì• Store Accounts"), KeyboardButton(text="üìä My Accounts")],
        [KeyboardButton(text="üîê Login"), KeyboardButton(text="üì§ Export")],
        [KeyboardButton(text="üóë Delete"), KeyboardButton(text="üíÄ Terminate")],
        [KeyboardButton(text="üßπ Purge Account"), KeyboardButton(text="üì• Import Session")],
        [KeyboardButton(text="üì° Check Active Telegram Numbers"), KeyboardButton(text="üìã Check Session Health")],
        [KeyboardButton(text="üîé Check Session Authorization")]   # ‚úÖ ‡¶®‡¶§‡ßÅ‡¶® ‡¶¨‡ßã‡¶§‡¶æ‡¶Æ
    ],
    resize_keyboard=True
)

# ‚úÖ Terminate ‡¶Ö‡¶™‡¶∂‡¶®‡ßá‡¶∞ ‡¶á‡¶®‡¶≤‡¶æ‡¶á‡¶® ‡¶ï‡ßÄ‡¶¨‡ßã‡¶∞‡ßç‡¶°
terminate_keyboard = InlineKeyboardMarkup(
    inline_keyboard=[
        [InlineKeyboardButton(text="üí• Terminate", callback_data="confirm_terminate")]
    ]
)

# ‚úÖ Store Accounts ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‚ùå Cancel Inline Keyboard
store_cancel_inline_keyboard = InlineKeyboardMarkup(
    inline_keyboard=[
        [InlineKeyboardButton(text="‚ùå Cancel", callback_data="cancel_store")]
    ]
)


@router.message(CommandStart())
async def start_cmd(message: Message):
    user_state.pop(message.from_user.id, None)  # ‚Üê ‡¶è‡¶ü‡¶æ ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßã
    await message.answer("‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ! ‡¶è‡¶ï‡¶ü‡¶ø ‡¶Ö‡¶™‡¶∂‡¶® ‡¶¨‡ßá‡¶õ‡ßá ‡¶®‡¶ø‡¶®:", reply_markup=main_menu)


@router.message(lambda msg: msg.text == "üì• Store Accounts")
async def store_accounts(message: types.Message):
    user_state.pop(message.from_user.id, None)
    user_state[message.from_user.id] = "awaiting_phone"
    await message.answer(
        "üì± ‡¶´‡ßã‡¶® ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶¶‡¶ø‡¶® (e.g. +8801XXXXXXXXX):",
        reply_markup=store_cancel_inline_keyboard
    )

@router.callback_query(lambda c: c.data == "cancel_store")
async def cancel_store_account(callback_query: types.CallbackQuery):
    user_state.pop(callback_query.from_user.id, None)
    await callback_query.message.answer(
        "‚úÖ ‡¶Ö‡¶™‡¶æ‡¶∞‡ßá‡¶∂‡¶® ‡¶¨‡¶æ‡¶§‡¶ø‡¶≤ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§", reply_markup=main_menu
    )

@router.message(lambda msg: user_state.get(msg.from_user.id) == "awaiting_phone")
async def get_otp(message: Message):
    phone = message.text.strip()
    user_state[message.from_user.id] = {"phone": phone}
    await message.answer("üì® OTP ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã ‡¶π‡¶ö‡ßç‡¶õ‡ßá...")
    asyncio.create_task(send_otp(message.chat.id, phone))


async def send_otp(chat_id, phone):
    try:
        client = TelegramClient(StringSession(), API_ID, API_HASH)
        await client.connect()

        if await client.is_user_authorized():
            await bot.send_message(chat_id, "üîì ‡¶è‡¶á ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ï‡¶æ‡¶â‡¶®‡ßç‡¶ü ‡¶á‡¶§‡¶ø‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶≤‡¶ó‡¶á‡¶® ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§")
            await client.disconnect()
            return

        sent = await client.send_code_request(phone)
        user_state[chat_id]['session'] = client.session.save()
        user_state[chat_id]['phone_code_hash'] = sent.phone_code_hash

        await bot.send_message(chat_id, "üì© ‡¶ï‡ßã‡¶° ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã ‡¶π‡ßü‡ßá‡¶õ‡ßá, ‡¶è‡¶ñ‡¶® OTP ‡¶¶‡¶ø‡¶®:")
        await client.disconnect()

    except Exception as e:
        await bot.send_message(chat_id, f"‚ùå OTP ‡¶™‡¶æ‡¶†‡¶æ‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: {e}")

@router.message(lambda msg: isinstance(user_state.get(msg.from_user.id), dict) and "phone" in user_state[msg.from_user.id])
async def save_session(message: Message):
    code = message.text.strip()
    state = user_state[message.from_user.id]
    phone = state["phone"]
    session_str = state.get("session")
    phone_code_hash = state.get("phone_code_hash")
    session_dir = get_user_session_dir(message.from_user.id)
    session_path = os.path.join(session_dir, f"{message.from_user.id}_{phone.replace('+', '')}.session")

    if not phone_code_hash:
        await message.answer("‚ùå ‡¶ï‡ßã‡¶° hash ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø‡•§ ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§")
        return

    try:
        # ‚úÖ ‡¶™‡ßÅ‡¶∞‡ßã‡¶®‡ßã ‡¶ì ‡¶®‡¶§‡ßÅ‡¶® ‡¶∏‡ßá‡¶∂‡¶® ‡¶¶‡ßÅ‡¶á‡¶ü‡¶æ‡¶á ‡¶∏‡¶æ‡¶™‡ßã‡¶∞‡ßç‡¶ü ‡¶ï‡¶∞‡¶¨‡ßá
        try:
            client = TelegramClient(StringSession(session_str), API_ID, API_HASH)
        except Exception:
            client = TelegramClient(session_str, API_ID, API_HASH)

        await client.connect()
        await client.sign_in(phone=phone, code=code, phone_code_hash=phone_code_hash)

        # ‚úÖ ‡¶≤‡ßã‡¶ï‡¶æ‡¶≤ ‡¶∏‡ßá‡¶∂‡¶® ‡¶´‡¶æ‡¶á‡¶≤ ‡¶∏‡ßá‡¶≠
        with open(session_path, "wb") as f:
            f.write(client.session.save().encode("utf-8"))

        await client.disconnect()

        # ‚úÖ Google Drive ‡¶è ‡¶Ü‡¶™‡¶≤‡ßã‡¶°
        try:
            user_id = str(message.from_user.id)
            file_name = os.path.basename(session_path)
            file_id = upload_to_drive(session_path, file_name)
            await message.answer(
                f"‚úÖ ‡¶∏‡ßá‡¶∂‡¶® ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá Google Drive ‡¶è ‡¶Ü‡¶™‡¶≤‡ßã‡¶° ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá!\nüìÇ File ID: `{file_id}`",
                parse_mode="Markdown"
            )
        except Exception as e:
            await message.answer(f"‚ö†Ô∏è Google Drive ‡¶è ‡¶Ü‡¶™‡¶≤‡ßã‡¶° ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶•: {e}")

        # ‚úÖ ‡¶≤‡ßã‡¶ï‡¶æ‡¶≤ ‡¶´‡¶æ‡¶á‡¶≤ ‡¶Æ‡ßÅ‡¶õ‡ßá ‡¶´‡ßá‡¶≤‡ßã (‡¶∏‡¶ø‡¶ï‡¶ø‡¶â‡¶∞‡¶ø‡¶ü‡¶ø‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø)
        try:
            os.remove(session_path)
        except:
            pass

        await message.answer(f"‚úÖ ‡¶∏‡ßá‡¶∂‡¶® ‡¶∏‡ßá‡¶≠ ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®: {phone}")

    except Exception as e:
        await message.answer(f"‚ùå ‡¶≤‡¶ó‡¶á‡¶® ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶•: {e}")
    finally:
        user_state.pop(message.from_user.id, None)

from aiogram.types import Message
from googleapiclient.errors import HttpError

@router.message(lambda msg: msg.text == "üìä My Accounts")
async def list_accounts(message: Message):
    """Drive ‡¶•‡ßá‡¶ï‡ßá ‡¶á‡¶â‡¶ú‡¶æ‡¶∞‡¶≠‡¶ø‡¶§‡ßç‡¶§‡¶ø‡¶ï ‡¶∏‡ßá‡¶∂‡¶® ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü + ‡¶¶‡ßá‡¶∂‡¶≠‡¶ø‡¶§‡ßç‡¶§‡¶ø‡¶ï ‡¶∏‡ßÅ‡¶®‡ßç‡¶¶‡¶∞ ‡¶™‡ßç‡¶∞‡ßã‡¶´‡ßá‡¶∂‡¶®‡¶æ‡¶≤ ‡¶≠‡¶ø‡¶â"""
    user_state.pop(message.from_user.id, None)

    try:
        # üîπ Google Drive ‡¶•‡ßá‡¶ï‡ßá ‡¶´‡¶æ‡¶á‡¶≤ ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ
        results = drive_service.files().list(
            q=f"'{GOOGLE_FOLDER_ID}' in parents and trashed=false",
            fields="files(id, name, createdTime)",
            orderBy="createdTime desc"
        ).execute()

        files = results.get("files", [])
        user_id = str(message.from_user.id)

        # üîπ ‡¶á‡¶â‡¶ú‡¶æ‡¶∞‡¶≠‡¶ø‡¶§‡ßç‡¶§‡¶ø‡¶ï ‡¶´‡¶æ‡¶á‡¶≤ ‡¶´‡¶ø‡¶≤‡ßç‡¶ü‡¶æ‡¶∞
        files = [f for f in files if f["name"].startswith(user_id + "_")]

        if not files:
            await message.answer("‚ùå ‡¶ï‡ßã‡¶®‡ßã ‡¶∏‡ßá‡¶∂‡¶® ‡¶´‡¶æ‡¶á‡¶≤ ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø (Drive ‡¶è)‡•§")
            return

        # üîπ ‡¶¶‡ßá‡¶∂‡¶≠‡¶ø‡¶§‡ßç‡¶§‡¶ø‡¶ï ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ï‡¶æ‡¶â‡¶®‡ßç‡¶ü ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶ó‡¶£‡¶®‡¶æ
        country_counts = {}
        for f in files:
            filename = f["name"]
            parts = filename.split("_")
            if len(parts) < 2:
                continue

            phone_part = parts[1]
            if not phone_part:
                continue

            flag, country = get_country_info("+" + phone_part)
            if country not in country_counts:
                country_counts[country] = {"flag": flag, "count": 0}
            country_counts[country]["count"] += 1

        # üîπ ‡¶¶‡ßá‡¶∂‡¶≠‡¶ø‡¶§‡ßç‡¶§‡¶ø‡¶ï ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™ ‡¶§‡ßà‡¶∞‡¶ø
        country_summary = {}
        total_accounts = sum(info["count"] for info in country_counts.values())

        for country, info in country_counts.items():
            country_summary[(info["flag"], country)] = info["count"]

        # üîπ ‡¶∏‡ßÅ‡¶®‡ßç‡¶¶‡¶∞‡¶≠‡¶æ‡¶¨‡ßá ‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú
        msg = "üìä <b>ùó†ùòÜ ùóîùó∞ùó∞ùóºùòÇùóªùòÅùòÄ ùó¶ùòÇùó∫ùó∫ùóÆùóøùòÜ</b>\n"
        msg += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"

        color_emojis = ["üü¢", "üü°", "üîµ", "üü£", "üü§", "üü†", "‚ö™", "‚ö´"]

        for i, ((flag, name), count) in enumerate(
            sorted(country_summary.items(), key=lambda x: x[1], reverse=True), 1
        ):
            color = color_emojis[i % len(color_emojis)]
            msg += f"{color} {flag} <b>{name}</b> ‚Äî <code>{count}</code> Account{'s' if count > 1 else ''}\n"

        msg += "\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        msg += f"üóÇÔ∏è <b>Total Linked:</b> <code>{total_accounts}</code> Account{'s' if total_accounts > 1 else ''} ‚úÖ"

        await message.answer(msg, parse_mode="HTML")

    except Exception as e:
        await message.answer(f"‚ö†Ô∏è ‡¶ï‡ßã‡¶®‡ßã ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶ò‡¶ü‡ßá‡¶õ‡ßá:\n<code>{e}</code>", parse_mode="HTML")

@router.message(lambda msg: msg.text == "üì§ Export")
async def export_prompt_drive(message: Message):
    user_state.pop(message.from_user.id, None)

    results = drive_service.files().list(
        q=f"'{GOOGLE_FOLDER_ID}' in parents and trashed = false",
        fields="files(id, name)",
        orderBy="createdTime desc"
    ).execute()
    
    files = results.get("files", [])
    user_id = str(message.from_user.id)
    files = [f for f in files if f["name"].startswith(user_id + "_")]
    if not files:
        await message.answer("‚ùå ‡¶ï‡ßã‡¶®‡ßã ‡¶∏‡ßá‡¶∂‡¶® ‡¶®‡ßá‡¶á (Drive ‡¶è)‡•§")
        return

    msg_list = "\n".join([f"{i+1}. {f['name']}" for i,f in enumerate(files)])
    await message.answer(f"üì§ Export ‡¶ï‡¶∞‡¶§‡ßá ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶¶‡¶ø‡¶® (e.g. 1,2):\n\n{msg_list}")
    user_state[message.from_user.id] = {"action":"awaiting_export_indices", "drive_files": files}


@router.message(lambda msg: isinstance(user_state.get(msg.from_user.id), dict) and user_state[msg.from_user.id].get("action")=="awaiting_export_indices")
async def export_sessions_drive(message: Message):
    try:
        data = user_state[message.from_user.id]
        files = data.get("drive_files", [])
        indices = [int(i.strip())-1 for i in message.text.split(",")]
        for idx in indices:
            if idx < 0 or idx >= len(files):
                continue
            meta = files[idx]
            local_path = download_drive_file_to_tmp(meta["id"], meta["name"])
            await message.answer_document(FSInputFile(local_path), caption=f"üì§ {meta['name']}")
            try:
                os.remove(local_path)
            except:
                pass

    except Exception as e:
        await message.answer(f"‚ùå ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: {e}")
    finally:
        user_state.pop(message.from_user.id, None)


@router.message(lambda msg: msg.text == "üóë Delete")
async def delete_prompt_drive(message: Message):
    """Google Drive ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡ßÅ‡¶®‡ßç‡¶¶‡¶∞‡¶≠‡¶æ‡¶¨‡ßá ‡¶∏‡ßá‡¶∂‡¶® ‡¶°‡¶ø‡¶≤‡¶ø‡¶ü ‡¶ï‡¶∞‡¶æ‡¶∞ UI"""
    user_state.pop(message.from_user.id, None)

    try:
        results = drive_service.files().list(
            q=f"'{GOOGLE_FOLDER_ID}' in parents and trashed = false",
            fields="files(id, name, createdTime)",
            orderBy="createdTime desc"
        ).execute()

        files = results.get("files", [])
        user_id = str(message.from_user.id)
        files = [f for f in files if f["name"].startswith(user_id + "_")]

        if not files:
            await message.answer("‚ùå ‡¶ï‡ßã‡¶®‡ßã ‡¶∏‡ßá‡¶∂‡¶® ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø (Drive ‡¶è)‡•§")
            return

        # üåü ‡¶∏‡ßÅ‡¶®‡ßç‡¶¶‡¶∞‡¶≠‡¶æ‡¶¨‡ßá ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü ‡¶§‡ßà‡¶∞‡¶ø
        msg = "üóë <b>ùó¶ùó≤ùóπùó≤ùó∞ùòÅ ùó¶ùó≤ùòÄùòÄùó∂ùóºùóªùòÄ ùóßùóº ùóóùó≤ùóπùó≤ùòÅùó≤</b>\n\n"
        for i, f in enumerate(files, 1):
            name = f["name"].replace(".session", "")
            phone = name.split("_")[-1]
            if not phone:
                continue

            # ‡¶¶‡ßá‡¶∂‡ßá‡¶∞ ‡¶™‡¶§‡¶æ‡¶ï‡¶æ + ‡¶®‡¶æ‡¶Æ ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ
            flag, country = get_country_info("+" + phone if not phone.startswith("+") else phone)
            msg += f"‚¨¢ {flag} <b>{country}</b> ‚Äî +{phone}\n"

        msg += "\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
        msg += f"üì¶ <b>Total Sessions:</b> {len(files)} ‚úÖ\n"
        msg += "üñäÔ∏è <b>Reply with numbers to delete (e.g. 1,2,3)</b>"

        await message.answer(msg, parse_mode="HTML")
        user_state[message.from_user.id] = {
            "action": "awaiting_delete_indices",
            "drive_files": files
        }

    except Exception as e:
        await message.answer(f"‚ö†Ô∏è ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: {e}")


@router.message(lambda msg: isinstance(user_state.get(msg.from_user.id), dict) 
                 and user_state[msg.from_user.id].get("action") == "awaiting_delete_indices")
async def delete_sessions_drive(message: Message):
    """‡¶è‡¶ï ‡¶¨‡¶æ ‡¶è‡¶ï‡¶æ‡¶ß‡¶ø‡¶ï ‡¶∏‡ßá‡¶∂‡¶® ‡¶≤‡¶ó‡¶Ü‡¶â‡¶ü + ‡¶°‡¶ø‡¶≤‡¶ø‡¶ü"""
    try:
        data = user_state[message.from_user.id]
        files = data.get("drive_files", [])
        indices = [int(i.strip()) - 1 for i in message.text.split(",") if i.strip().isdigit()]

        deleted = []
        for idx in indices:
            if idx < 0 or idx >= len(files):
                continue

            file_meta = files[idx]
            file_id = file_meta["id"]
            file_name = file_meta["name"]

            try:
                # üîÑ ‡¶∏‡ßá‡¶∂‡¶® ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶ì ‡¶≤‡¶ó‡¶Ü‡¶â‡¶ü
                local_path = download_drive_file_to_tmp(file_id, file_name)
                with open(local_path, "rb") as f:
                    session_str = f.read().decode()

                client = TelegramClient(StringSession(session_str), API_ID, API_HASH)
                await client.connect()
                if await client.is_user_authorized():
                    await client.log_out()
                await client.disconnect()

                # üóë Drive ‡¶•‡ßá‡¶ï‡ßá ‡¶Æ‡ßÅ‡¶õ‡ßá ‡¶´‡ßá‡¶≤‡¶æ
                drive_service.files().delete(fileId=file_id).execute()
                deleted.append(file_name)

                try:
                    os.remove(local_path)
                except:
                    pass

            except Exception as e:
                await message.answer(f"‚ö†Ô∏è `{file_name}` ‡¶Æ‡ßÅ‡¶õ‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: {e}")

        # üåà ‡¶∏‡ßÅ‡¶®‡ßç‡¶¶‡¶∞ ‡¶Ü‡¶â‡¶ü‡¶™‡ßÅ‡¶ü ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú
        if deleted:
            msg = "üßπ <b>ùóóùó≤ùóπùó≤ùòÅùó∂ùóºùóª ùó¶ùòÇùó∫ùó∫ùóÆùóøùòÜ</b>\n\n"
            for i, name in enumerate(deleted, 1):
                phone = name.split("_")[-1].replace(".session", "")
                flag, country = get_country_info("+" + phone if not phone.startswith("+") else phone)
                msg += f"{i}. {flag} <b>{country}</b> ‚Äî +{phone}\n"
            msg += "\n‚úÖ <b>Deleted:</b> {0} session(s)".format(len(deleted))
        else:
            msg = "‚ö†Ô∏è ‡¶ï‡ßã‡¶®‡ßã ‡¶∏‡ßá‡¶∂‡¶® ‡¶°‡¶ø‡¶≤‡¶ø‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡¶®‡¶ø‡•§"

        await message.answer(msg, parse_mode="HTML")

    except Exception as e:
        await message.answer(f"‚ùå ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: {e}")
    finally:
        user_state.pop(message.from_user.id, None)

@router.message(lambda msg: msg.text == "üîê Login")
async def login_prompt_drive(message: Message):
    """Google Drive ‡¶•‡ßá‡¶ï‡ßá ‡¶á‡¶â‡¶ú‡¶æ‡¶∞‡ßá‡¶∞ ‡¶∏‡ßá‡¶∂‡¶® ‡¶´‡¶æ‡¶á‡¶≤ ‡¶∏‡ßÅ‡¶®‡ßç‡¶¶‡¶∞‡¶≠‡¶æ‡¶¨‡ßá ‡¶¶‡ßá‡¶ñ‡¶æ‡¶¨‡ßá"""
    user_state.pop(message.from_user.id, None)
    await message.answer("‚è≥ Google Drive ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡ßá‡¶∂‡¶® ‡¶≤‡ßã‡¶° ‡¶π‡¶ö‡ßç‡¶õ‡ßá...")

    try:
        # üîπ Drive ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡ßá‡¶∂‡¶® ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü
        results = drive_service.files().list(
            q=f"'{GOOGLE_FOLDER_ID}' in parents and trashed=false",
            fields="files(id, name, createdTime)",
            orderBy="createdTime desc"
        ).execute()

        files = results.get("files", [])
        user_id = str(message.from_user.id)
        user_files = [f for f in files if f["name"].startswith(user_id + "_")]

        if not user_files:
            await message.answer("‚ùå ‡¶ï‡ßã‡¶®‡ßã ‡¶∏‡ßá‡¶∂‡¶® ‡¶®‡ßá‡¶á (Drive ‡¶è)‡•§")
            return

        # ‡¶∏‡ßÅ‡¶®‡ßç‡¶¶‡¶∞ ‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü‡ßá ‡¶¶‡ßá‡¶ñ‡¶æ‡¶ì (‡¶¶‡ßá‡¶∂‡¶≠‡¶ø‡¶§‡ßç‡¶§‡¶ø‡¶ï ‡¶™‡¶§‡¶æ‡¶ï‡¶æ)
        msg_lines = ["üåê <b>Select Account To Login</b>\n"]
        for i, f in enumerate(user_files, 1):
            name = f["name"].replace(".session", "")
            parts = name.split("_")
            phone = parts[-1] if len(parts) > 1 else name
            flag, country = get_country_info("+" + phone if not phone.startswith("+") else phone)
            msg_lines.append(f"‚¨¢ {flag}  <b>{country}</b> ‚Äî {phone}")

        msg_lines.append("\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
        msg_lines.append(f"üóÇÔ∏è <b>Total Accounts:</b> {len(user_files)} ‚úÖ")
        msg_lines.append("üñäÔ∏è Reply a number to login.")

        await message.answer("\n".join(msg_lines), parse_mode="HTML")
        user_state[message.from_user.id] = {"action": "awaiting_otp_drive", "files": user_files}

    except Exception as e:
        await message.answer(f"‚ö†Ô∏è Drive ‡¶≤‡ßã‡¶°‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: <code>{e}</code>", parse_mode="HTML")


@router.message(lambda msg: isinstance(user_state.get(msg.from_user.id), dict) and user_state[msg.from_user.id].get("action") == "awaiting_otp_drive")
async def watch_for_otp_drive(message: Message):
    """Drive ‡¶•‡ßá‡¶ï‡ßá ‡¶®‡¶ø‡¶∞‡ßç‡¶¨‡¶æ‡¶ö‡¶ø‡¶§ ‡¶∏‡ßá‡¶∂‡¶® ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡ßá Telegram OTP ‡¶ï‡ßç‡¶Ø‡¶æ‡¶ö ‡¶ï‡¶∞‡¶¨‡ßá"""
    try:
        index = int(message.text.strip()) - 1
        state = user_state.get(message.from_user.id)
        files = state["files"]

        if index < 0 or index >= len(files):
            await message.answer("‚ö†Ô∏è ‡¶≠‡ßÅ‡¶≤ ‡¶á‡¶®‡¶°‡ßá‡¶ï‡ßç‡¶∏ ‡¶¶‡¶ø‡ßü‡ßá‡¶õ‡ßá‡¶®‡•§")
            return

        file_info = files[index]
        file_id = file_info["id"]
        file_name = file_info["name"]

        await message.answer(f"üìÇ Selected: <code>{file_name}</code>\n‚è≥ Downloading...", parse_mode="HTML")

        # üîπ Drive ‡¶•‡ßá‡¶ï‡ßá ‡¶´‡¶æ‡¶á‡¶≤ ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶°
        local_path = download_drive_file_to_tmp(file_id, file_name)

        # üîπ ‡¶∏‡ßá‡¶∂‡¶® ‡¶≤‡ßã‡¶°
        with open(local_path, "rb") as f:
            data = f.read()
        try:
            session_str = data.decode()
            client = TelegramClient(StringSession(session_str), API_ID, API_HASH)
        except:
            client = TelegramClient(local_path, API_ID, API_HASH)

        await client.connect()
        try:
            me = await client.get_me()
            phone = me.phone if me else "Unknown"
            await message.answer(f"üì± Phone: <code>{phone}</code>\nüì§ Waiting for OTP from 777000...", parse_mode="HTML")
        except:
            await message.answer("üì§ Waiting for Telegram OTP (777000)...")

        otp_caught = asyncio.get_event_loop().create_future()

        @client.on(events.NewMessage)
        async def otp_handler(event):
            if event.sender_id != 777000:
                return

            text = event.raw_text
            match_en = re.search(r"(\d{4,6})", text)
            match_ar = re.search(r"([\u0660-\u0669]{4,6})", text)
            otp = match_en.group(1) if match_en else None
            if otp and not otp_caught.done():
                otp_caught.set_result((otp, text))

        try:
            otp, text = await asyncio.wait_for(otp_caught, timeout=300)
            await bot.send_message(
                message.chat.id,
                f"‚úÖ OTP Code: <code>{otp}</code>\n\nMessage:\n<code>{text}</code>",
                parse_mode="HTML"
            )
        except asyncio.TimeoutError:
            await message.answer("‚ùå OTP Timeout ‚Äî ‡ß´ ‡¶Æ‡¶ø‡¶®‡¶ø‡¶ü ‡¶™‡¶æ‡¶∞ ‡¶π‡ßü‡ßá ‡¶ó‡ßá‡¶õ‡ßá‡•§")
        finally:
            await client.disconnect()

    except Exception as e:
        await message.answer(f"‚ùå ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: <code>{e}</code>", parse_mode="HTML")
    finally:
        user_state.pop(message.from_user.id, None)
        try:
            os.remove(local_path)
        except:
            pass

@router.message(lambda msg: msg.text == "üíÄ Terminate")
async def terminate_prompt_drive(message: Message):
    """Google Drive ‡¶•‡ßá‡¶ï‡ßá ‡¶ü‡¶æ‡¶∞‡ßç‡¶Æ‡¶ø‡¶®‡ßá‡¶ü ‡¶∏‡ßá‡¶∂‡¶® ‡¶¶‡ßá‡¶ñ‡¶æ‡ßü ‡¶∏‡ßÅ‡¶®‡ßç‡¶¶‡¶∞ ‡¶°‡¶ø‡¶ú‡¶æ‡¶á‡¶®‡ßá"""
    user_state.pop(message.from_user.id, None)

    try:
        results = drive_service.files().list(
            q=f"'{GOOGLE_FOLDER_ID}' in parents and trashed = false",
            fields="files(id, name)"
        ).execute()

        files = results.get("files", [])
        user_id = str(message.from_user.id)
        files = [f for f in files if f["name"].startswith(user_id + "_")]

        if not files:
            await message.answer("‚ùå ‡¶ï‡ßã‡¶®‡ßã ‡¶∏‡ßá‡¶∂‡¶® ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø (Drive ‡¶è)‡•§")
            return

        # üåê ‡¶™‡ßç‡¶∞‡¶´‡ßá‡¶∂‡¶®‡¶æ‡¶≤ ‡¶°‡¶ø‡¶ú‡¶æ‡¶á‡¶®
        msg = "üíÄ <b>ùó¶ùó≤ùóπùó≤ùó∞ùòÅ ùó¶ùó≤ùòÄùòÄùó∂ùóºùóª ùóßùóº ùóßùó≤ùóøùó∫ùó∂ùóªùóÆùòÅùó≤</b>\n\n"
        for i, f in enumerate(files, 1):
            name = f["name"].replace(".session", "")
            phone = name.split("_")[-1]
            if not phone:
                continue

            # üá∏üá¶ ‡¶¶‡ßá‡¶∂‡ßá‡¶∞ ‡¶™‡¶§‡¶æ‡¶ï‡¶æ ‡¶ì ‡¶®‡¶æ‡¶Æ ‡¶Ü‡¶®‡¶õ‡ßá
            flag, country = get_country_info("+" + phone if not phone.startswith("+") else phone)
            msg += f"‚¨¢ {flag} <b>{country}</b> ‚Äî +{phone}\n"

        msg += "\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
        msg += f"üìõ <b>Total Sessions:</b> {len(files)} ‚úÖ\n"
        msg += "‚úèÔ∏è <b>Reply a number to terminate.</b>"

        await message.answer(msg, parse_mode="HTML")
        user_state[message.from_user.id] = {
            "action": "awaiting_terminate_index",
            "drive_files": files
        }

    except Exception as e:
        await message.answer(f"‚ö†Ô∏è ‡¶ï‡ßã‡¶®‡ßã ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶ò‡¶ü‡ßá‡¶õ‡ßá:\n`{e}`", parse_mode="Markdown")


@router.message(lambda msg: isinstance(user_state.get(msg.from_user.id), dict) and user_state[msg.from_user.id].get("action") == "awaiting_terminate_index")
async def terminate_sessions_drive(message: Message):
    """‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶Ø‡ßá‡¶á ‡¶∏‡ßá‡¶∂‡¶® ‡¶á‡¶®‡¶°‡ßá‡¶ï‡ßç‡¶∏ ‡¶¶‡ßá‡ßü, ‡¶∏‡ßá‡¶ü‡¶ø ‡¶ü‡¶æ‡¶∞‡ßç‡¶Æ‡¶ø‡¶®‡ßá‡¶ü‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶§‡ßÅ‡¶§ ‡¶ï‡¶∞‡ßá"""
    try:
        data = user_state[message.from_user.id]
        files = data.get("drive_files", [])
        index = int(message.text.strip()) - 1

        if index < 0 or index >= len(files):
            await message.answer("‚ö†Ô∏è ‡¶≠‡ßÅ‡¶≤ ‡¶á‡¶®‡¶°‡ßá‡¶ï‡ßç‡¶∏ ‡¶¶‡¶ø‡ßü‡ßá‡¶õ‡ßá‡¶®‡•§")
            user_state.pop(message.from_user.id, None)
            return

        file_meta = files[index]
        file_id = file_meta["id"]
        file_name = file_meta["name"]

        # ‚úÖ ‡¶∏‡ßá‡¶∂‡¶® ‡¶´‡¶æ‡¶á‡¶≤ ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶°
        await message.answer(f"‚è≥ <b>Loading session:</b> <code>{file_name}</code>", parse_mode="HTML")
        local_path = download_drive_file_to_tmp(file_id, file_name)
        with open(local_path, "rb") as f:
            session_str = f.read().decode()

        client = TelegramClient(StringSession(session_str), API_ID, API_HASH)
        await client.connect()

        if not await client.is_user_authorized():
            await message.answer("‚ùå ‡¶è‡¶á ‡¶∏‡ßá‡¶∂‡¶® ‡¶Ö‡¶®‡ßÅ‡¶Æ‡ßã‡¶¶‡¶ø‡¶§ ‡¶®‡ßü‡•§")
            await client.disconnect()
            os.remove(local_path)
            user_state.pop(message.from_user.id, None)
            return

        sessions = await client(GetAuthorizationsRequest())
        auth_list = sessions.authorizations

        msg_lines = []
        for i, auth in enumerate(auth_list):
            platform = auth.platform or "Unknown"
            device_model = auth.device_model or "Unknown"
            ip = auth.ip or "Unknown"
            current = "üü¢ (Current Device)" if auth.current else ""
            msg_lines.append(f"{i+1}. {platform} ‚Äî {device_model} ‚Äî {ip} {current}")

        # ‚úÖ inline keyboard define
        terminate_keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="üí£ Confirm Terminate", callback_data="confirm_terminate")],
            [InlineKeyboardButton(text="üîô Cancel", callback_data="cancel_action")]
        ])

        user_state[message.from_user.id] = {
            "session_str": session_str,
            "drive_file_id": file_id,
            "drive_file_name": file_name
        }

        msg_text = "üì± <b>Active Devices</b>\n\n" + "\n".join(msg_lines)
        await message.answer(msg_text, parse_mode="HTML", reply_markup=terminate_keyboard)

    except Exception as e:
        await message.answer(f"‚ùå ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: {e}")
        try:
            await client.disconnect()
        except:
            pass
        user_state.pop(message.from_user.id, None)


@router.callback_query(lambda c: c.data == "confirm_terminate")
async def handle_terminate_callback(callback_query: types.CallbackQuery):
    """‡¶∏‡ßá‡¶∂‡¶® ‡¶ü‡¶æ‡¶∞‡ßç‡¶Æ‡¶ø‡¶®‡ßá‡¶ü ‡¶™‡ßç‡¶∞‡¶ï‡ßç‡¶∞‡¶ø‡ßü‡¶æ"""
    user_id = callback_query.from_user.id
    state = user_state.get(user_id)

    if not state or "session_str" not in state:
        await callback_query.message.answer("‚ö†Ô∏è ‡¶∏‡ßá‡¶∂‡¶® ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø ‡¶¨‡¶æ ‡¶ü‡¶æ‡¶á‡¶Æ‡¶Ü‡¶â‡¶ü ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§", reply_markup=main_menu)
        return

    session_str = state["session_str"]

    try:
        client = TelegramClient(StringSession(session_str), API_ID, API_HASH)
        await client.connect()

        if not await client.is_user_authorized():
            await callback_query.message.answer("‚ùå ‡¶∏‡ßá‡¶∂‡¶® ‡¶Ö‡¶®‡ßÅ‡¶Æ‡ßã‡¶¶‡¶ø‡¶§ ‡¶®‡ßü‡•§", reply_markup=main_menu)
            await client.disconnect()
            return

        sessions = await client(GetAuthorizationsRequest())
        terminated, failed = 0, 0

        for auth in sessions.authorizations:
            if not auth.current:
                try:
                    await client(ResetAuthorizationRequest(auth.hash))
                    terminated += 1
                except:
                    failed += 1

        if terminated > 0:
            msg = f"‚úÖ <b>{terminated}</b> ‡¶°‡¶ø‡¶≠‡¶æ‡¶á‡¶∏ ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶∏‡¶æ‡¶á‡¶® ‡¶Ü‡¶â‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§"
            if failed > 0:
                msg += f"\n‚ö†Ô∏è {failed} ‡¶°‡¶ø‡¶≠‡¶æ‡¶á‡¶∏ ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶• ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§"
        else:
            msg = "‚ö†Ô∏è ‡¶ï‡ßã‡¶®‡ßã ‡¶Ö‡¶®‡ßç‡¶Ø ‡¶°‡¶ø‡¶≠‡¶æ‡¶á‡¶∏ ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø‡•§"

        await callback_query.message.answer(msg, parse_mode="HTML", reply_markup=main_menu)

    except Exception as e:
        if "24 hours" in str(e):
            await callback_query.message.answer(
                "‚ö†Ô∏è Telegram ‡¶®‡¶ø‡ßü‡¶Æ ‡¶Ö‡¶®‡ßÅ‡¶Ø‡¶æ‡ßü‡ßÄ, ‡¶®‡¶§‡ßÅ‡¶® ‡¶°‡¶ø‡¶≠‡¶æ‡¶á‡¶∏ ‡¶¶‡¶ø‡ßü‡ßá ‡ß®‡ß™ ‡¶ò‡¶£‡ßç‡¶ü‡¶æ‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá Terminate ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá ‡¶®‡¶æ‡•§",
                reply_markup=main_menu
            )
        else:
            await callback_query.message.answer(f"‚ùå ‡¶ü‡¶æ‡¶∞‡ßç‡¶Æ‡¶ø‡¶®‡ßá‡¶ü ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø: {e}", reply_markup=main_menu)
    finally:
        await client.disconnect()
        user_state.pop(user_id, None)


# ====== BEAUTIFIED: Import / Purge / Number-check features (Ready to paste) ======
from aiogram import types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from telethon import TelegramClient
from telethon.sessions import StringSession
from telethon.tl.functions.messages import DeleteHistoryRequest
from telethon.tl.functions.channels import LeaveChannelRequest
from telethon.tl.functions.contacts import ImportContactsRequest, DeleteContactsRequest, GetContactsRequest
from telethon.tl.types import InputPhoneContact, InputUser

# shared state
user_state = getattr(globals(), "user_state", {})  # preserve existing if any
if not isinstance(user_state, dict):
    user_state = {}
# ensure router exists
router = globals().get("router") or types.Router()

# -------------------
# Inline keyboards / constants (styled)
# -------------------
purge_option_keyboard = InlineKeyboardMarkup(inline_keyboard=[
    [InlineKeyboardButton(text="üóëÔ∏è Delete All Messages", callback_data="purge_messages")],
    [InlineKeyboardButton(text="üö™ Leave All Groups/Channels", callback_data="purge_groups")],
    [InlineKeyboardButton(text="üë• Delete All Contacts", callback_data="purge_contacts")],
    [InlineKeyboardButton(text="‚¨ÖÔ∏è Back to Main Menu", callback_data="back_to_menu")]
])

terminate_keyboard = InlineKeyboardMarkup(inline_keyboard=[
    [InlineKeyboardButton(text="üí£ Confirm Terminate", callback_data="confirm_terminate")],
    [InlineKeyboardButton(text="üîô Cancel", callback_data="cancel_action")]
])

# -------------------
# 1) üì• Import Session (polished)
# -------------------
@router.message(lambda msg: msg.text == "üì• Import Session")
async def import_prompt_design(message: types.Message):
    user_state.pop(message.from_user.id, None)
    ui = (
        "üì• <b>Import Telegram Session</b>\n\n"
        "üíæ Please upload your <code>.session</code> file (Document).\n\n"
        "Supported formats:\n"
        "‚Ä¢ StringSession (text)\n"
        "‚Ä¢ Telethon .session (SQLite)\n\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        "‚öôÔ∏è After import it will be optionally uploaded to Google Drive (if Drive configured)."
    )
    await message.answer(ui, parse_mode="HTML")
    user_state[message.from_user.id] = {"action": "awaiting_import_session"}


@router.message(lambda msg: msg.document and isinstance(user_state.get(msg.from_user.id), dict)
                and user_state[msg.from_user.id].get("action") == "awaiting_import_session")
async def handle_import_session(message: types.Message):
    try:
        file = message.document
        if not file.file_name.endswith(".session"):
            await message.answer("‚ùå Only `.session` files are accepted. Please resend.")
            return

        session_dir = get_user_session_dir(message.from_user.id)
        os.makedirs(session_dir, exist_ok=True)
        file_path = os.path.join(session_dir, file.file_name)

        await bot.download(file, destination=file_path)
        await message.answer("‚è≥ Session received ‚Äî validating...")

        # Try both formats: text string session first, else sqlite file session
        client = None
        try:
            with open(file_path, "rb") as f:
                raw = f.read()
            try:
                stext = raw.decode().strip()
                client = TelegramClient(StringSession(stext), API_ID, API_HASH)
            except Exception:
                # fallback to file path session (Telethon can use path to sqlite session)
                client = TelegramClient(file_path, API_ID, API_HASH)

            await client.connect()
            if not await client.is_user_authorized():
                await message.answer("‚ùå Session invalid or expired. Please re-login and try again.")
                await client.disconnect()
                os.remove(file_path)
                return

            me = await client.get_me()
            await message.answer(f"‚úÖ Session imported: <b>{me.first_name}</b> ‚Äî <code>{me.phone}</code>", parse_mode="HTML")

            # optional: upload to drive (if function present)
            try:
                file_id = None
                if "upload_to_drive" in globals():
                    file_id = upload_to_drive(file_path, os.path.basename(file_path))
                if file_id:
                    await message.answer(f"‚òÅÔ∏è Uploaded to Google Drive (File ID: <code>{file_id}</code>)", parse_mode="HTML")
            except Exception as e:
                await message.answer(f"‚ö†Ô∏è Drive upload failed: {e}")

            await client.disconnect()
        except Exception as e:
            await message.answer(f"‚ùå Import error: {e}")
            try:
                if client:
                    await client.disconnect()
            except:
                pass
            if os.path.exists(file_path):
                os.remove(file_path)
        finally:
            user_state.pop(message.from_user.id, None)

    except Exception as e:
        user_state.pop(message.from_user.id, None)
        await message.answer(f"‚ùå Unexpected: {e}")


# -------------------
# 2) üßπ Purge Account (polished flow)
# -------------------
@router.message(lambda msg: msg.text == "üßπ Purge Account")
async def purge_start(message: types.Message):
    user_state.pop(message.from_user.id, None)
    ui = (
        "üßπ <b>Purge Account Control Panel</b>\n\n"
        "Choose an option below to purge data from the selected Telegram session.\n\n"
        "‚ö†Ô∏è Use carefully ‚Äî actions are irreversible."
    )
    await message.answer(ui, parse_mode="HTML")
    # Ask for session file
    await message.answer("üìÇ Please send the <code>.session</code> file to purge (as Document).", parse_mode="HTML")
    user_state[message.from_user.id] = {"action": "awaiting_purge_session"}


@router.message(lambda msg: msg.document and isinstance(user_state.get(msg.from_user.id), dict)
                and user_state[msg.from_user.id].get("action") == "awaiting_purge_session")
async def purge_session_received(message: types.Message):
    try:
        doc = message.document
        if not doc.file_name.endswith(".session"):
            await message.answer("‚ùå Please upload a valid .session file.")
            return

        local = f"/tmp/{doc.file_name}"
        await bot.download(doc, destination=local)

        with open(local, "r") as f:
            session_str = f.read().strip()

        # store session_str and show purge options
        user_state[message.from_user.id] = {"action": "awaiting_purge_choice", "session_str": session_str}
        ui = "üîß <b>Purge Options</b>\n\nSelect one:\n\n‚Ä¢ üóë Delete All Messages\n‚Ä¢ üö™ Leave All Groups/Channels\n‚Ä¢ üë• Delete All Contacts"
        await message.answer(ui, parse_mode="HTML", reply_markup=purge_option_keyboard)
    except Exception as e:
        user_state.pop(message.from_user.id, None)
        await message.answer(f"‚ùå Error receiving session: {e}")


@router.callback_query(lambda c: c.data.startswith("purge_"))
async def handle_purge_action(callback_query: types.CallbackQuery):
    action = callback_query.data  # purge_messages / purge_groups / purge_contacts
    uid = callback_query.from_user.id
    state = user_state.get(uid)
    if not state or "session_str" not in state:
        await callback_query.message.answer("‚ö†Ô∏è Session missing. Please upload .session file first.")
        return

    session_str = state["session_str"]
    client = TelegramClient(StringSession(session_str), API_ID, API_HASH)
    await client.connect()

    try:
        if not await client.is_user_authorized():
            await callback_query.message.answer("‚ùå Session unauthorized.")
            await client.disconnect()
            user_state.pop(uid, None)
            return

        # show a processing message
        await callback_query.message.answer("‚è≥ Processing, please wait...")

        if action == "purge_messages":
            # delete messages from user/bot dialogs
            dialogs = await client.get_dialogs()
            deleted = 0
            for d in dialogs:
                try:
                    if d.is_user or d.is_bot:
                        await client(DeleteHistoryRequest(peer=d.entity, just_clear=False, revoke=True))
                        deleted += 1
                except:
                    pass
            await callback_query.message.answer(f"‚úÖ Messages cleared in {deleted} chats.")
        elif action == "purge_groups":
            left = 0
            async for d in client.iter_dialogs():
                try:
                    if d.is_group or d.is_channel:
                        await client(LeaveChannelRequest(channel=d.entity))
                        left += 1
                except:
                    pass
            await callback_query.message.answer(f"üö™ Left {left} groups/channels.")
        elif action == "purge_contacts":
            result = await client(GetContactsRequest(hash=0))
            users = result.users
            input_users = [InputUser(u.id, u.access_hash) for u in users if u.access_hash]
            if input_users:
                await client(DeleteContactsRequest(id=input_users))
                await callback_query.message.answer(f"üë• Deleted {len(input_users)} contacts.")
            else:
                await callback_query.message.answer("‚ö†Ô∏è No contacts found.")
        else:
            await callback_query.message.answer("‚ö†Ô∏è Unknown option.")

    except Exception as e:
        await callback_query.message.answer(f"‚ùå Purge error: {e}")
    finally:
        try:
            await client.disconnect()
        except:
            pass
        user_state.pop(uid, None)


@router.callback_query(lambda c: c.data == "back_to_menu")
async def _back_menu(callback_query: types.CallbackQuery):
    # fallback to main menu (if defined)
    await callback_query.message.edit_text("üè† Main Menu", parse_mode="HTML", reply_markup=globals().get("main_menu"))


# -------------------
# 3) üì° Check Active Telegram Numbers (polished)
# -------------------
@router.message(lambda msg: msg.text == "üì° Check Active Telegram Numbers")
async def check_numbers_start(message: types.Message):
    user_state.pop(message.from_user.id, None)
    ui = (
        "üì° <b>Number Checker</b>\n\n"
        "1) Send your <code>.session</code> file (Document).\n"
        "2) Then send numbers (one per line)."
    )
    await message.answer(ui, parse_mode="HTML")
    user_state[message.from_user.id] = {"action": "awaiting_check_session"}


@router.message(lambda msg: msg.document and isinstance(user_state.get(msg.from_user.id), dict)
                and user_state[msg.from_user.id].get("action") == "awaiting_check_session")
async def check_session_received(message: types.Message):
    try:
        doc = message.document
        if not doc.file_name.endswith(".session"):
            await message.answer("‚ùå Please upload a valid .session file.")
            return
        local = f"/tmp/{doc.file_name}"
        await bot.download(doc, destination=local)
        with open(local, "r") as f:
            session_str = f.read().strip()

        user_state[message.from_user.id] = {"action": "awaiting_numbers", "session_str": session_str}
        await message.answer("üßæ Now send numbers (one per line), example:\n+88017XXXXXXX\n+9665XXXXXXX", parse_mode="HTML")
    except Exception as e:
        user_state.pop(message.from_user.id, None)
        await message.answer(f"‚ùå Error: {e}")


@router.message(lambda msg: isinstance(user_state.get(msg.from_user.id), dict) and user_state[msg.from_user.id].get("action") == "awaiting_numbers")
async def handle_numbers_check(message: types.Message):
    try:
        lines = [l.strip() for l in message.text.splitlines() if l.strip()]
        if not lines:
            await message.answer("‚ö†Ô∏è No numbers provided.")
            return

        state = user_state[message.from_user.id]
        session_str = state.get("session_str")
        client = TelegramClient(StringSession(session_str), API_ID, API_HASH)
        await client.connect()

        if not await client.is_user_authorized():
            await message.answer("‚ùå Session unauthorized.")
            await client.disconnect()
            user_state.pop(message.from_user.id, None)
            return

        await message.answer("üîç Checking numbers ‚Äî please wait...")

        contacts = [InputPhoneContact(client_id=i, phone=n.replace("+", ""), first_name="Check", last_name="") for i, n in enumerate(lines)]
        res = await client(ImportContactsRequest(contacts))
        found = res.users or []

        active_list = []
        for u in found:
            if getattr(u, "phone", None):
                flag, country = get_country_info("+" + str(u.phone))
                active_list.append(f"{flag} <b>{country}</b> ‚Äî +{u.phone}")

        # cleanup imported contacts
        if found:
            # convert to InputUser list for delete
            try:
                await client(DeleteContactsRequest(id=[InputUser(u.id, u.access_hash) for u in found]))
            except:
                pass

        if active_list:
            msg = "‚úÖ <b>Active Telegram numbers found:</b>\n\n" + "\n".join(active_list)
        else:
            msg = "‚ùå No active Telegram accounts found in the provided numbers."

        await message.answer(msg, parse_mode="HTML")

    except Exception as e:
        await message.answer(f"‚ùå Error: {e}")
    finally:
        try:
            await client.disconnect()
        except:
            pass
        user_state.pop(message.from_user.id, None)

# ============================================================
# üìã CHECK SESSION HEALTH FEATURE (by Nahid Bot)
# ============================================================
import random, time

SPAMBOT_USERNAME = "@SpamBot"
SPAMBOT_REPLY_TIMEOUT = 25
SPAMBOT_POLL_INTERVAL = 2
CHECK_DELAY = 4   # ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶∏‡ßá‡¶∂‡¶®‡ßá‡¶∞ ‡¶Æ‡¶æ‡¶ù‡ßá ‡ß™ ‡¶∏‡ßá‡¶ï‡ßá‡¶®‡ßç‡¶° ‡¶¨‡¶ø‡¶∞‡¶§‡¶ø (Rate Limit ‡¶è‡¶°‡¶º‡¶æ‡¶§‡ßá)

async def check_with_spambot(client):
    """@SpamBot ‡¶è /start ‡¶™‡¶æ‡¶†‡¶ø‡¶Ø‡¶º‡ßá ‡¶∞‡¶ø‡¶™‡ßç‡¶≤‡¶æ‡¶á ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡¶¨‡ßá"""
    try:
        await asyncio.sleep(random.uniform(1, 2))
        await client.send_message(SPAMBOT_USERNAME, "/start")

        deadline = time.time() + SPAMBOT_REPLY_TIMEOUT
        while time.time() < deadline:
            msgs = await client.get_messages(SPAMBOT_USERNAME, limit=4)
            for m in msgs:
                if hasattr(m, "out") and not m.out:
                    text = (m.message or "").strip()
                    low = text.lower()
                    if any(k in low for k in ["limited", "suspended", "restricted", "frozen", "ban", "blocked"]):
                        return ("limited", text)
                    if any(k in low for k in ["warning", "spam", "suspicious", "report"]):
                        return ("warning", text)
                    return ("ok", text)
            await asyncio.sleep(SPAMBOT_POLL_INTERVAL)
        return ("no_reply", "No reply from SpamBot.")
    except Exception as e:
        return ("error", str(e))


@router.message(lambda msg: msg.text == "üìã Check Session Health")
async def check_all_sessions_health(message: Message):
    """‡¶≤‡¶æ‡¶á‡¶≠ ‡¶™‡ßç‡¶∞‡¶ó‡ßç‡¶∞‡ßá‡¶∏ ‡¶ì ‡¶°‡¶ø‡¶ü‡ßá‡¶á‡¶≤ ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü‡¶∏‡¶π ‡¶∏‡ßá‡¶∂‡¶® ‡¶π‡ßá‡¶≤‡¶• ‡¶ö‡ßá‡¶ï"""
    progress_msg = await message.answer("üîç ‡¶∏‡ßá‡¶∂‡¶® ‡¶π‡ßá‡¶≤‡¶• ‡¶ö‡ßá‡¶ï ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...\n\n‚è≥ ‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶§‡ßÅ‡¶§‡¶ø ‡¶®‡¶ø‡¶ö‡ßç‡¶õ‡ßá...")

    try:
        # Google Drive ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡ßá‡¶∂‡¶® ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü ‡¶Ü‡¶®‡ßã
        results = drive_service.files().list(
            q=f"'{GOOGLE_FOLDER_ID}' in parents and trashed=false",
            fields="files(id, name)",
            orderBy="createdTime desc"
        ).execute()
        files = results.get("files", [])
        user_id = str(message.from_user.id)
        user_files = [f for f in files if f["name"].startswith(user_id + "_")]

        if not user_files:
            await progress_msg.edit_text("‚ùå ‡¶ï‡ßã‡¶®‡ßã ‡¶∏‡ßá‡¶∂‡¶® ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø‡•§")
            return

        total = len(user_files)
        active = frozen = limited = failed = 0

        frozen_set = set()
        limited_set = set()
        failed_set = set()

        await progress_msg.edit_text(f"üì¶ ‡¶Æ‡ßã‡¶ü {total} ‡¶ü‡¶ø ‡¶∏‡ßá‡¶∂‡¶® ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡¶æ ‡¶π‡¶¨‡ßá...\n\nProgress: 0/{total} ‚è≥")

        for index, meta in enumerate(user_files, start=1):
            file_id = meta["id"]
            file_name = meta["name"]

            # fallback number (session name ‡¶•‡ßá‡¶ï‡ßá)
            try:
                raw_num = file_name.split("_")[1].split(".")[0]
                phone_number = "+" + raw_num if not raw_num.startswith("+") else raw_num
            except Exception:
                phone_number = "Unknown"

            flag, country = get_country_info(phone_number)

            try:
                local_path = download_drive_file_to_tmp(file_id, file_name)
                with open(local_path, "rb") as f:
                    session_str = f.read().decode()

                client = TelegramClient(StringSession(session_str), API_ID, API_HASH)
                await client.connect()

                if not await client.is_user_authorized():
                    failed += 1
                    failed_set.add(f"{flag} {phone_number}")
                    await client.disconnect()
                    os.remove(local_path)
                    continue

                me = await client.get_me()
                phone_number = "+" + str(me.phone)
                flag, country = get_country_info(phone_number)

                # ‚úÖ ‡¶ü‡ßá‡¶∏‡ßç‡¶ü ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú ‡¶™‡¶æ‡¶†‡¶æ‡¶ì
                can_send = True
                try:
                    await client.send_message("me", "‚úÖ Health Check Test")
                except Exception:
                    can_send = False

                # ‚úÖ SpamBot ‡¶ö‡ßá‡¶ï
                status, _ = await check_with_spambot(client)

                # ‡¶´‡¶≤‡¶æ‡¶´‡¶≤ ‡¶®‡¶ø‡¶∞‡ßç‡¶ß‡¶æ‡¶∞‡¶£
                if not can_send:
                    frozen += 1
                    frozen_set.add(f"{flag} {phone_number}")
                elif status in ("limited", "warning"):
                    limited += 1
                    limited_set.add(f"{flag} {phone_number}")
                elif status == "ok":
                    active += 1
                else:
                    failed += 1
                    failed_set.add(f"{flag} {phone_number}")

                await client.disconnect()
                os.remove(local_path)

            except Exception:
                failed += 1
                failed_set.add(f"{flag} {phone_number}")

            # ‡¶≤‡¶æ‡¶á‡¶≠ ‡¶™‡ßç‡¶∞‡¶ó‡ßç‡¶∞‡ßá‡¶∏ ‡¶Ü‡¶™‡¶°‡ßá‡¶ü
            progress_text = (
                f"üìã <b>Session Health Check Running...</b>\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                f"‚è≥ Progress: {index}/{total}\n\n"
                f"‚úÖ Active: {active}\n"
                f"‚ö†Ô∏è Limited: {limited}\n"
                f"üßä Frozen: {frozen}\n"
                f"‚ùå Failed: {failed}\n"
            )
            await progress_msg.edit_text(progress_text, parse_mode="HTML")
            await asyncio.sleep(CHECK_DELAY)

        # üîö ‡¶´‡¶æ‡¶á‡¶®‡¶æ‡¶≤ ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü
        report = (
            f"üèÅ <b>Session Health Check Completed!</b>\n\n"
            f"‚úÖ Active: {active}\n"
            f"‚ö†Ô∏è Limited: {limited}\n"
            f"üßä Frozen: {frozen}\n"
            f"‚ùå Failed: {failed}\n"
            f"üì¶ Total: {total}\n\n"
        )

        # Frozen
        if frozen_set:
            report += "üßä <b>Frozen Sessions:</b>\n"
            for num in frozen_set:
                report += f"{num}\n"
            report += "\n"

        # Limited
        if limited_set:
            report += "‚ö†Ô∏è <b>Limited Sessions:</b>\n"
            for num in limited_set:
                report += f"{num}\n"
            report += "\n"

        # Failed
        if failed_set:
            report += "‚ùå <b>Failed Sessions:</b>\n"
            for num in failed_set:
                report += f"{num}\n"

        await progress_msg.edit_text(report, parse_mode="HTML")

    except Exception as e:
        await progress_msg.edit_text(f"‚ùå ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø ‡¶ò‡¶ü‡ßá‡¶õ‡ßá: <code>{e}</code>", parse_mode="HTML")

# ---------------------------
# üîé Session Authorization Checker (no OTP required)
# ---------------------------
@router.message(lambda msg: msg.text == "üîé Check Session Authorization")
async def check_session_authorization(message: Message):
    """
    GPT: This handler checks all session files in Drive for whether they are
    still authorized (works without needing the SIM/OTP).
    """
    progress = await message.answer("üîç Checking session authorizations...\n\n‚è≥ Preparing...")
    try:
        # list files in drive
        results = drive_service.files().list(
            q=f"'{GOOGLE_FOLDER_ID}' in parents and trashed=false",
            fields="files(id, name)",
            orderBy="createdTime desc"
        ).execute()
        files = results.get("files", [])
        user_id = str(message.from_user.id)
        user_files = [f for f in files if f["name"].startswith(user_id + "_")]

        if not user_files:
            await progress.edit_text("‚ùå ‡¶ï‡ßã‡¶®‡ßã ‡¶∏‡ßá‡¶∂‡¶® ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø (Drive ‡¶è)‡•§")
            return

        total = len(user_files)
        ok_list = []
        bad_list = []
        unknown_list = []
        await progress.edit_text(f"üì¶ ‡¶Æ‡ßã‡¶ü {total} ‡¶∏‡ßá‡¶∂‡¶® ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶ó‡ßá‡¶≤ ‚Äî Progress: 0/{total}")

        for idx, meta in enumerate(user_files, start=1):
            file_id = meta["id"]; file_name = meta["name"]
            # try to infer phone from filename as fallback
            try:
                raw_num = file_name.split("_", 1)[1].replace(".session", "")
                fallback_phone = ("+" + raw_num) if not raw_num.startswith("+") else raw_num
            except Exception:
                fallback_phone = "Unknown"

            status_line = f"{idx}/{total} ‚Äî {file_name} : "

            try:
                local = download_drive_file_to_tmp(file_id, file_name)
                with open(local, "rb") as fh:
                    data = fh.read()
                # attempt to decode string session; if fails, use file path for Telethon
                try:
                    session_text = data.decode()
                    client = TelegramClient(StringSession(session_text), API_ID, API_HASH)
                except Exception:
                    client = TelegramClient(local, API_ID, API_HASH)

                await client.connect()
                try:
                    if await client.is_user_authorized():
                        me = await client.get_me()
                        phone = getattr(me, "phone", None)
                        if phone:
                            ph = "+" + str(phone)
                        else:
                            ph = fallback_phone
                        flag, country = get_country_info(ph)
                        ok_list.append((flag, ph, file_name))
                    else:
                        # unauthorized
                        bad_list.append((fallback_phone, file_name))
                except Exception as e:
                    # could not fetch me; mark unknown but include filename
                    unknown_list.append((str(e)[:80], file_name))
                finally:
                    await client.disconnect()
                # remove local temp
                try: os.remove(local)
                except: pass

            except Exception as e:
                # can't download / open - treat as failed/unknown
                unknown_list.append((str(e)[:80], file_name))

            # update live progress
            done = idx
            await progress.edit_text(
                f"üîç Checking authorizations...\nProgress: {done}/{total}\n\n"
                f"‚úÖ OK: {len(ok_list)}  |  ‚ùå Unauthorized: {len(bad_list)}  |  ‚ùì Errors: {len(unknown_list)}"
            )

            # small delay to be gentle on Drive / I/O
            await asyncio.sleep(0.8)

        # build final report text
        report = "üèÅ <b>Session Authorization Report</b>\n\n"
        report += f"üì¶ Total checked: {total}\n"
        report += f"‚úÖ Authorized: {len(ok_list)}\n"
        report += f"‚ùå Unauthorized / Expired: {len(bad_list)}\n"
        report += f"‚ùì Errors: {len(unknown_list)}\n\n"

        if ok_list:
            report += "‚úÖ <b>Authorized Sessions (can be used without OTP)</b>:\n"
            for flag, ph, fname in ok_list:
                report += f"{flag} {ph} ‚Äî <code>{fname}</code>\n"
            report += "\n"
        if bad_list:
            report += "‚ùå <b>Unauthorized / Expired Sessions (need re-login / SIM)</b>:\n"
            for ph, fname in bad_list:
                report += f"{ph} ‚Äî <code>{fname}</code>\n"
            report += "\n"
        if unknown_list:
            report += "‚ùì <b>Errors / Could not determine</b>:\n"
            for err, fname in unknown_list:
                report += f"{fname} ‚Äî <code>{err}</code>\n"

        await progress.edit_text(report, parse_mode="HTML")

    except Exception as e:
        await progress.edit_text(f"‚ùå Error while checking sessions: <code>{e}</code>", parse_mode="HTML")

# ====== end of block ======


import asyncio
import logging

async def heartbeat():
    while True:
        print("‚úÖ Bot is alive...")
        await asyncio.sleep(10)

async def main():
    logging.basicConfig(level=logging.INFO)
    print("üöÄ Starting bot...")

    await bot.delete_webhook(drop_pending_updates=True)

    asyncio.create_task(heartbeat())  # optional
    await dp.start_polling(bot)

if __name__ == "__main__":
    import nest_asyncio
    nest_asyncio.apply()
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        print("‚ùå Bot stopped manually.")